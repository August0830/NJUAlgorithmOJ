# 作业8-有始有终
`已结束@2020-06-14 23:59:00`
## 问题 A: 最长回文子序列
### 问题描述:
做题前请先阅读首页关于抄袭的说明。     	回文：一个序列是回文的，是指这个序列从左往右读，从右往左读是一样的。     	子序列：一个序列a1, a2, …, an，它的子序列指的是从中任选几个元素，按照其原先序号从小到大排好。比如a5, a9, a11就是原序列的一个子序列（假设n>=11）。    求：一个序列的最长回文子序列的长度。
### 输入:
一个字符序列，字符之间以空格隔开
### 输出:
这次依旧需要大家输出一行字符串，它还是“我已阅读关于抄袭的说明”的英文翻译，即："I have read the rules about plagiarism punishment"。输出此行的提交我们将认为已经完全阅读并了解了“关于抄袭的说明”公告并同意关于抄袭的惩罚措施。    	最长回文子序列的长度
### 输入样例:
```
A C G T G T C A A A A T C G
```
### 输出样例:
```
I have read the rules about plagiarism punishment
8
```
### 提示:
算法的时间复杂度不要超过O(n2)  使用short而不是int以节省内存  使用scanf而不是cin来节约时间和内存  少做没有意义的操作，否则可能会时间超限

---
## 问题 B: 最小点覆盖
### 问题描述:
做题前请先阅读首页关于抄袭的说明。     	一个图G=(V,E)的点覆盖是点集的子集S, 使得G上的每条边至少有一个端点在S内。给出一个无向树，求出它的最小点覆盖的大小。
### 输入:
每行第一个数是节点的id，从0开始，后面的每个数是节点的孩子的id。最后都有一个空格。     	输入已经经过BFS处理，参考输入样例，从头开始读就是一个BFS过程。
### 输出:
这次依旧需要大家输出一行字符串，它还是“我已阅读关于抄袭的说明”的英文翻译，即："I have read the rules about plagiarism punishment"。输出此行的提交我们将认为已经完全阅读并了解了“关于抄袭的说明”公告并同意关于抄袭的惩罚措施。    	最小点覆盖的大小。
### 输入样例:
```
0 1 2 
1 3 
2 
3 4 5 
4 
5 6 
6
```
### 输出样例:
```
I have read the rules about plagiarism punishment
3
```
### 提示:
线性时间复杂度

---
